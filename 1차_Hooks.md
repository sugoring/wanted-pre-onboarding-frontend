## 클래스(Class) 
- 라이프사이클 메소드 제공: React 컴포넌트의 생명주기에 따라 다양한 작업을 수행할 수 있는 메소드를 제공
- 상태 정의: 생성자(constructor)에서 this.state를 통해 컴포넌트의 상태를 정의

## Hooks
- React 16.8 버전 
- this 키워드 없이도 상태 및 로직을 관리할 수 있음

---
# Hooks
### useState
- **설명**: 함수형 컴포넌트에서 상태 관리를 가능하게 하는 Hook, 해 컴포넌트의 상태를 생성하고, 업데이트함
- **초기화**: `const [state, setState] = useState(initialState);`
  - `initialState`: 상태의 초기 값
- **동작 방식**: `useState`는 상태 값(`state`)과 상태를 업데이트하는 함수(`setState`)를 배열로 반환함
- **업데이트**: `setState(newState);`
  - `newState`를 사용하여 상태를 업데이트함, 상태가 업데이트되면 컴포넌트는 재렌더링됨

### useEffect
- **설명**: 컴포넌트의 렌더링 이후 사이드 이펙트를 수행하는 Hook, 데이터 fetching, 구독 설정, 수동 DOM 조작 등에 사용함
- **초기화**: `useEffect(() => { /* 사이드 이펙트 로직 */ }, [dependencies]);`
  - 사이드 이펙트 로직을 첫 번째 인자로, 의존성 배열을 두 번째 인자로 받음
- **동작 방식**: 컴포넌트 렌더링 후, 의존성 배열에 명시된 값이 변경될 때마다 사이드 이펙트 로직이 실행함
- **업데이트**: 의존성 배열 내 변수의 변경을 감지하여 사이드 이펙트 로직을 조건부로 실행함

### useMemo
- **설명**: 계산 비용이 높은 연산의 결과를 메모이제이션하여 성능 최적화에 도움을 주는 Hook
- **초기화**: `const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`
  - 계산에 사용되는 함수와 의존성 배열을 인자로 받음
- **동작 방식**: 의존성 배열 내의 값이 변경될 때만 함수가 재계산되고, 아닌 경우 이전에 계산된 값을 재사용함
- **업데이트**: 의존성 배열의 요소가 변경되면, 메모이제이션된 값이 재계산됨

### useCallback
- **설명**: 함수를 메모이제이션하여 컴포넌트의 불필요한 재렌더링을 방지하는 Hook
- **초기화**: `const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);`
  - 메모이제이션할 함수와 의존성 배열을 인자로 받음
- **동작 방식**: 의존성 배열 내의 값이 변경될 때만 함수가 재생성되고, 아닌 경우 이전에 생성된 함수를 재사용함
- **업데이트**: 의존성 배열의 요소가 변경되면, 메모이제이션된 함수가 재생성됨

### useRef
- **설명**: DOM 요소에 직접 접근하거나, 리렌더링에 영향을 받지 않는 값을 저장하기 위해 사용하는 Hook
- **초기화**: `const refContainer = useRef(initialValue);`
  - `initialValue`: ref 객체의 초기 값
- **동작 방식**: `useRef`는 `.current` 속성을 통해 생성된 ref 객체에 접함, ref 객체는 컴포넌트의 생명 주기 동안 일정하게 유지됨
- **업데이트**: `.current` 속성을 직접 변경하여 ref 객체를 업데이트할 수 있음, 이러한 업데이트는 컴포넌트의 재렌더링을 유발하지 않음